# AI Context: 客製化 Table 通用 CRUD 操作抽象類設計

## 🎯 需求 & 目標

設計並實作一個通用的抽象類，能夠為客製化資料庫 table 提供完整的 CRUD（Create, Read, Update, Delete）操作，讓開發者可以快速實作特定 table 的資料存取層，而不需要重複寫相似的程式碼。

## 📋 現有程式碼架構分析

### 現有架構優勢
1. **DTO 抽象類** (`src/abstracts/DTO.php`) - 提供了資料物件的基礎功能
2. **Table Helper** (`src/helpers/Table.php`) - 提供資料庫表創建和檢查功能
3. **Model 類別範例** - Txn.php, Wallet.php 展示了讀取操作的實作方式
4. **表創建類別** - CreateTxnTable.php, CreateWalletTable.php 處理表結構定義

### 現有架構問題 & 改進機會
⚠️ **你目前的設計存在以下問題，需要重新思考：**

1. **職責分離不清** - Model 類別同時負責資料表示和資料存取，違反單一職責原則
2. **CRUD 操作不完整** - 現有 Model 主要只有 Read 操作，缺乏完整的 Create, Update, Delete
3. **程式碼重複** - 每個 Model 都要重複寫相似的資料庫操作邏輯
4. **缺乏統一接口** - 沒有統一的 CRUD 介面，每個 Model 的方法命名不一致
5. **查詢方法僵硬** - 當前的查詢方法都是硬編碼，缺乏彈性

**🔥 建議：你應該採用 Repository Pattern + DTO 的設計模式，而不是把所有邏輯塞在 Model 裡面！**

## 🏗️ 設計思路 & 架構建議

### 推薦架構分層
```
Controller/Service Layer
        ↓
Repository Layer (我們要設計的抽象類)
        ↓
Database Layer (wpdb)
        ↓
DTO Layer (資料傳輸物件)
```

### 核心設計概念

#### 1. Repository 抽象類設計
```php
abstract class BaseRepository {
    // 定義通用的 CRUD 介面
    // 子類只需要實作特定的 table 設定
}
```

#### 2. DTO 保持純粹
- DTO 只負責資料表示和驗證
- 不包含業務邏輯和資料存取邏輯

#### 3. 靈活的查詢建構器
- 支援動態條件查詢
- 支援排序、分頁、關聯查詢

## 🎯 具體實作計畫

### 步驟 1: 設計 Repository 介面
創建 `src/interfaces/RepositoryInterface.php`
- 定義標準的 CRUD 方法簽名
- 定義查詢方法介面

### 步驟 2: 實作基礎 Repository 抽象類
創建 `src/abstracts/BaseRepository.php`
- 實作通用的 CRUD 操作
- 提供靈活的查詢建構器
- 處理資料庫連接和錯誤處理
- 整合現有的 Table helper

### 步驟 3: 重構現有 Model 為 Repository
- 創建 `TxnRepository.php` 繼承 BaseRepository
- 創建 `WalletRepository.php` 繼承 BaseRepository
- 保持現有的 DTO 類別（Txn.php, Wallet.php）

### 步驟 4: 提供工廠模式支援
創建 Repository Factory 簡化實例化

## 📝 Repository 抽象類需求規格

### 必須支援的 CRUD 操作
1. **Create** - `create(array $data): DTO|false`
2. **Read** - `find(int $id): ?DTO`, `findBy(array $criteria): DTO[]`
3. **Update** - `update(int $id, array $data): bool`
4. **Delete** - `delete(int $id): bool`

### 必須支援的查詢功能
1. **條件查詢** - WHERE 子句建構
2. **排序** - ORDER BY 支援
3. **分頁** - LIMIT OFFSET 支援
4. **計數** - COUNT 查詢
5. **關聯查詢** - JOIN 支援

### 必須支援的設定方法
1. **表名設定** - `getTableName(): string`
2. **主鍵設定** - `getPrimaryKey(): string`
3. **DTO 類別設定** - `getDTOClass(): string`
4. **可填充欄位** - `getFillable(): array`

## 🔧 實作細節要求

### 資料庫操作
- 使用 WordPress 的 `$wpdb` 進行資料庫操作
- 支援 prepared statements 防止 SQL injection
- 適當的錯誤處理和日誌記錄

### 資料驗證
- 整合現有的 DTO 驗證機制
- 支援欄位白名單（fillable）
- 資料型別自動轉換

### 效能考量
- 查詢結果緩存機制
- 批量操作支援
- 避免 N+1 查詢問題

## 📋 驗收標準

### 功能驗收
1. ✅ 能夠為 `j7_wallet_logs` 表實作完整的 CRUD 操作
2. ✅ 能夠為 `j7_wallets` 表實作完整的 CRUD 操作
3. ✅ 支援複雜的查詢條件（多重 WHERE, ORDER BY, LIMIT）
4. ✅ 正確處理資料驗證和錯誤
5. ✅ 與現有的 DTO 類別完美整合

### 程式碼品質驗收
1. ✅ 遵循 PSR-4 自動載入標準
2. ✅ 完整的 PHPDoc 註解
3. ✅ 遵循 SOLID 原則
4. ✅ 包含完整的單元測試
5. ✅ 符合 WordPress 編碼標準

### 使用範例驗收
```php
// 建立 Repository
$txnRepo = new TxnRepository();

// Create
$txn = $txnRepo->create([
    'wallet_id' => 1,
    'title' => 'Test Transaction',
    'type' => 'deposit',
    'point_changed' => 100.00
]);

// Read
$txn = $txnRepo->find(1);
$transactions = $txnRepo->findBy(['wallet_id' => 1]);

// Update
$success = $txnRepo->update(1, ['title' => 'Updated Title']);

// Delete
$success = $txnRepo->delete(1);

// 複雜查詢
$results = $txnRepo
    ->where('wallet_id', 1)
    ->where('type', 'deposit')
    ->orderBy('created_at', 'DESC')
    ->limit(10)
    ->get();
```

## 🚨 關鍵注意事項

1. **不要破壞現有功能** - 確保向下相容性
2. **效能優先** - 避免過度抽象影響效能
3. **WordPress 整合** - 充分利用 WordPress 的資料庫 API
4. **錯誤處理** - 提供明確的錯誤訊息和日誌
5. **擴展性** - 設計要考慮未來新增其他 table 的需求

## 🎯 最終目標

建立一個強大、靈活、易用的 Repository 抽象類，讓開發者可以：
- 5 分鐘內為新的客製化 table 建立完整的 CRUD 功能
- 減少 80% 的重複程式碼
- 提供一致、可預測的 API 介面
- 保持高效能和可維護性

**現在開始實作吧！記住：好的架構設計比快速實作更重要。**